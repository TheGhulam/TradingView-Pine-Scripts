// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © flow35

// @version=5
indicator("PVP + MTF MA + SBTC KL V13.1 + HMV + Supertrend", shorttitle="Gulbot v10", overlay=true, precision=4, max_lines_count = 500, max_bars_back = 500, max_labels_count = 500, max_boxes_count = 500)

// ======
// PVP
// ======

priceTxt  = str.tostring(close, format.mintick)
tickerTxt = syminfo.ticker

// Functions  -----------------------------------------------------------------------------------    

f_resInMinutes() =>
    _resInMinutes = timeframe.multiplier * (timeframe.isseconds ? 1. / 60 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : na)
    _resInMinutes

f_tfResInMinutes(_res) =>
    request.security(syminfo.tickerid, _res, f_resInMinutes())

f_tfIsIntraday(_res) =>
    [intraday, daily, weekly, monthly] = request.security(syminfo.tickerid, _res, [timeframe.isintraday, timeframe.isdaily, timeframe.isweekly, timeframe.ismonthly])
    check = intraday ? "Intraday" : daily ? "Daily" : weekly ? "Weekly" : monthly ? "Monthly" : "Error" 
    check

f_drawOnlyLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    id = line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)

f_drawLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    var id = line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)
    line.set_xy1(id, _x1, _y1)
    line.set_xy2(id, _x2, _y2)
    line.set_color(id, _color)
    id

f_drawOnlyBoxX(_left, _top, _right, _bottom, _border_color, _border_width, _border_style) =>
    box.new(_left, _top, _right, _bottom, _border_color, _border_width, _border_style, bgcolor=_border_color)

f_drawOnlyLabelX(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip)

f_drawLabelX(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    var id = label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip)
    label.set_xy(id, _x, _y)
    label.set_text(id, _text)
    label.set_tooltip(id, _tooltip)

f_getHighLow(_len, _calc, _offset) =>
    if _calc
        htf_l = low [_offset]
        htf_h = high[_offset]
        vol   = 0.
        
        if _len > 0
            for x = 0 to _len - 1
                htf_l := math.min(low [_offset + x], htf_l)
                htf_h := math.max(high[_offset + x], htf_h)
                vol += volume[_offset + x]

            // htf_l := math.min(low [_offset + _len], htf_l)
            // htf_h := math.max(high[_offset + _len], htf_h)
        
        [htf_h, htf_l, vol]

f_checkBreaches(arrayOfLines, extend) =>
    int qtyOfLines = array.size(arrayOfLines)
    for lineNo = 0 to (qtyOfLines > 0 ? qtyOfLines - 1 : na)
        if lineNo < array.size(arrayOfLines)
            line  currentLine   = array.get(arrayOfLines, lineNo)
            float lineLevel     = line.get_y1(currentLine)
            bool  lineWasCrossed = math.sign(close[1] - lineLevel) != math.sign(close - lineLevel)
            bool  lineWasTouched = math.sign(close[1] - lineLevel) != math.sign(low - lineLevel) or math.sign(close[1] - lineLevel) != math.sign(high - lineLevel) 

            if lineWasCrossed and extend == 'Until Bar Cross'
                array.remove(arrayOfLines, lineNo)
                // int(na)
            else if lineWasTouched and extend == 'Until Bar Touch'
                array.remove(arrayOfLines, lineNo)
                // int(na)
            else
                line.set_x2(currentLine, bar_index)
                // int(na)
    int(na)

// Inputs ---------------------------------------------------------------------------------------

group_volume_profile    = 'Periodic Volume Profile'

periodic_tf       = input.timeframe("30", "Periodic Timeframe", group = group_volume_profile, tooltip= 'Note that some higher timeframe may not work properly due to maximum historical bars limitation')
regular_sess      = input.bool(false, 'Profile resets on Regular Session', group = group_volume_profile, tooltip = 'For tickers with Extended Trading Hours')

tooltip_vp        = 'Volume Profile - displays total trading activity over a specified time period at specific price levels'
volumeProfile     = input.bool(false, 'Volume Profile (Common Interest)', inline='BB3', group = group_volume_profile, tooltip = tooltip_vp)
totalVolumeColor  = input.color(color.new(color.orange, 50), '' , inline='BB3', group = group_volume_profile)
vaVolumeColor     = input.color(color.new(color.gray, 50), '' , inline='BB3', group = group_volume_profile)

tooltip_va        = 'Value Area (VA) – The range of price levels in which a specified percentage of all volume was traded during the time period'
isValueArea       = input.float(68, "Value Area Volume %", minval = 0, maxval = 100               , group = group_volume_profile, tooltip = tooltip_va) / 100
profileLevels     = input.int(24, 'Number of Rows' , minval = 10, maxval = 100 , step = 1         , group = group_volume_profile)
profilePlacement  = input.string('Left', 'Placment', options = ['Right', 'Left', 'Next Period']                  , group = group_volume_profile)
profileWidth      = input.int(50, 'Profile Width %', minval = 0, maxval = 100                     , group = group_volume_profile) / 100

tooltip_poc       = 'Point of Control (POC) - The price level for the time period with the highest traded volume'
pointOfControl    = input.bool(true, 'Point of Control (PoC)'                       , inline='PoC', group = group_volume_profile, tooltip = tooltip_poc)
pocColor          = input.color(#ff525218, ''                       , inline='PoC', group = group_volume_profile)
pocWidth          = input.int(2, 'Width'                                           , inline='PoC', group = group_volume_profile)
pocExtend         = input.string('Until Bar Touch', 'Extend Point of Control (PoC)', options=['Until Last Bar', 'Until Bar Cross', 'Until Bar Touch', 'None'], group = group_volume_profile)

tooltip_vah       = 'Value Area High (VAH) - The highest price level within the value area'
valueAreaHigh     = input.bool(false, 'Value Area High (VAH)'                        , inline='VAH', group = group_volume_profile, tooltip = tooltip_vah)
vahColor          = input.color(color.new(color.blue, 0), ''                      , inline='VAH', group = group_volume_profile)

tooltip_val       = 'Value Area Low (VAL) - The lowest price level within the value area'
valueAreaLow      = input.bool(false, 'Value Area Low (VAL) '                        , inline='VAL', group = group_volume_profile, tooltip = tooltip_val)
valColor          = input.color(color.new(color.blue, 0), ''                      , inline='VAL', group = group_volume_profile)

vaBackground      = input.bool(false, 'Background Fill of Value Area (VA)'           , inline='vBG', group = group_volume_profile)
vaBackgroundColor = input.color(color.new(color.blue, 90), ''                     , inline='vBG', group = group_volume_profile)

backgroundFill    = input.bool(false, 'Background Fill of Profile Range'             , inline ='BG', group = group_volume_profile)
backgroundColor   = input.color(color.new(color.blue, 95), ''                     , inline ='BG', group = group_volume_profile)


// Definitions ---------------------------------------------------------------------------------- //
nzVolume          = nz(volume)

volumeStorageT    = array.new_float(profileLevels + 1, 0.)

var a_poc_lines   = array.new_line()

var x1            = 0
var x2            = 0
var levelAbovePoc = 0
var levelBelowPoc = 0
var pvtHigh1      = 0.
var pvtLow1       = 0.
var pvtLast       = ''
var pPOC          = 0.
var pvah          = 0.
var pval          = 0.

// Calculations --------------------------------------------------------------------------------- 
 
min_of_day      = hour * 60 + minute
intv            = 0
C_bar           = 0
bar_start       = false
period          = f_tfIsIntraday(periodic_tf)
daily_start     = regular_sess ? ta.barssince(session.isfirstbar_regular) : ta.barssince(session.isfirstbar)
weekly_start    = ta.barssince(ta.change(time("W")))
monthly_start   = ta.barssince(ta.change(time("1M")))
threeM_start    = ta.barssince(ta.change(time("3M")))
sixM_start      = ta.barssince(ta.change(time("6M")))
yearly_start    = ta.barssince(ta.change(time("12M")))
profileLength   = 0


if period == "Intraday"
    intv := int(f_tfResInMinutes(periodic_tf))
    C_bar := (min_of_day % intv)
    profileLength := ta.barssince(C_bar[1] == 0) +1
else if period == "Daily"
    C_bar := daily_start
    profileLength := daily_start[1]+1
else if period == "Weekly"
    C_bar := weekly_start
    profileLength := weekly_start[1]+1
else if period == "Monthly"
    C_bar := periodic_tf == "1M" ? monthly_start : periodic_tf == "3M" ? threeM_start : periodic_tf == "6M" ? sixM_start : periodic_tf == "12M" ? yearly_start : monthly_start
    profileLength := C_bar[1]+1

bar_start := C_bar == 0

// adjust for regular hour start
profileLength_adj = ta.barssince((session.islastbar_regular[1]))
profileLength_adj_ex = ta.barssince((session.isfirstbar_regular))
if regular_sess 
    bar_start := bar_start or session.isfirstbar_regular
    if not session.isfirstbar_regular
        if syminfo.session == session.regular
            profileLength :=  math.min(profileLength_adj, profileLength)
        else
            profileLength :=  math.min(profileLength_adj_ex, profileLength)

proceed = bar_start

if proceed
    x1 := x2
    x2 := bar_index

[priceHighest, priceLowest, tradedVolume] = f_getHighLow(profileLength, proceed, 1)
priceStep = (priceHighest - priceLowest) / profileLevels

pvtHigh  = priceHighest
pvtLow   = priceLowest

if not na(pvtHigh)
    pvtHigh1 := pvtHigh
    pvtLast  := 'H'

if not na(pvtLow)
    pvtLow1  := pvtLow
    pvtLast  := 'L'

if proceed and nzVolume and priceStep > 0 and bar_index > profileLength and profileLength > 0

    for barIndexx = 1 to profileLength
        level = 0
        barIndex = barIndexx
        
        for priceLevel = priceLowest to priceHighest by priceStep
            candleSize = high[barIndex] - low[barIndex]
            if high[barIndex] >= priceLevel and low[barIndex] < priceLevel + priceStep
                if high[barIndex] <= priceLevel + priceStep and low[barIndex] >= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex])
                else if high[barIndex] >= priceLevel + priceStep and low[barIndex] <= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * (priceStep/ candleSize))
                else if high[barIndex] >= priceLevel + priceStep
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * ((priceLevel + priceStep - low[barIndex]) / candleSize))
                else if low[barIndex] <= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * ((high[barIndex] - priceLevel) / candleSize))
            level += 1

    pocLevel          = array.indexof(volumeStorageT, array.max(volumeStorageT))
    totalVolumeTraded = array.sum(volumeStorageT) * isValueArea
    valueArea         = array.get(volumeStorageT, pocLevel)
    levelAbovePoc    := pocLevel
    levelBelowPoc    := pocLevel
    
    while valueArea < totalVolumeTraded
        if levelBelowPoc == 0 and levelAbovePoc == profileLevels - 1
            break

        volumeAbovePoc = 0.
        if levelAbovePoc < profileLevels - 1 
            volumeAbovePoc := array.get(volumeStorageT, levelAbovePoc + 1)

        volumeBelowPoc = 0.
        if levelBelowPoc > 0
            volumeBelowPoc := array.get(volumeStorageT, levelBelowPoc - 1)
        
        if volumeBelowPoc == 0 and volumeAbovePoc == 0
            break
        
        if volumeAbovePoc >= volumeBelowPoc
            valueArea     += volumeAbovePoc
            levelAbovePoc += 1
        else
            valueArea     += volumeBelowPoc
            levelBelowPoc -= 1

    for level = 0 to profileLevels - 1
        if volumeProfile
            startBoxIndex = profilePlacement == 'Right' ? bar_index - int(array.get(volumeStorageT, level) / array.max(volumeStorageT) * profileLength * profileWidth) : profilePlacement == 'Left' ? bar_index - profileLength : bar_index
            endBoxIndex   = profilePlacement == 'Right' ? bar_index  :  startBoxIndex + int( array.get(volumeStorageT, level) / array.max(volumeStorageT) * profileLength * profileWidth)
            f_drawOnlyBoxX(startBoxIndex, priceLowest + (level + 0.1) * priceStep, endBoxIndex, priceLowest + (level + 0.9) * priceStep, level >= levelBelowPoc and level <= levelAbovePoc ? totalVolumeColor : vaVolumeColor, 1, line.style_solid)

    if backgroundFill
        f_drawOnlyBoxX(bar_index - profileLength, priceHighest, bar_index - 1, priceLowest, backgroundColor, 1, line.style_dotted)

    if pointOfControl
        array.push(a_poc_lines, line.new(bar_index - profileLength, priceLowest + (array.indexof(volumeStorageT, array.max(volumeStorageT)) + 0.5) * priceStep, bar_index, priceLowest + (array.indexof(volumeStorageT, array.max(volumeStorageT)) + 0.5) * priceStep, color=pocColor, width = pocWidth))
        
    vah = f_drawOnlyLineX(bar_index - profileLength, priceLowest + (levelAbovePoc + 1.00) * priceStep, bar_index-1, priceLowest + (levelAbovePoc + 1.00) * priceStep, xloc.bar_index, extend.none, valueAreaHigh ? vahColor : #00000000, line.style_solid, 2)
    val = f_drawOnlyLineX(bar_index - profileLength, priceLowest + (levelBelowPoc + 0.00) * priceStep, bar_index-1, priceLowest + (levelBelowPoc + 0.00) * priceStep, xloc.bar_index, extend.none, valueAreaLow  ? valColor : #00000000, line.style_solid, 2)

    if vaBackground
        linefill.new(vah, val, vaBackgroundColor)

    pPOC := priceLowest + (array.indexof(volumeStorageT, array.max(volumeStorageT)) + 0.5) * priceStep
    pvah := priceLowest + (levelAbovePoc + 1.00) * priceStep
    pval := priceLowest + (levelBelowPoc + 0.00) * priceStep

current_start = ta.barssince(bar_start)

var a_profileD    = array.new_box()
profileLength    := current_start
priceHighest     := ta.highest(high, profileLength > 0 ? profileLength + 1 : 1)
priceLowest      := ta.lowest (low , profileLength > 0 ? profileLength + 1 : 1)
priceStep        := (priceHighest - priceLowest) / profileLevels
var pocLevel      = 0

[_, _, tradedVolume1] = f_getHighLow(profileLength, true, 0)
        
DPoC = priceLowest + (array.indexof(volumeStorageT, array.max(volumeStorageT)) + .50) * priceStep
DVAH = priceLowest + (levelAbovePoc + 1.00) * priceStep
DVAL = priceLowest + (levelBelowPoc + 0.00) * priceStep

var line DPoC_l = line.new(na, na, na, na, color=pocColor, width = 2)
var line DVAH_l = line.new(na, na, na, na, color=vahColor, width = 2)
var line DVAL_l = line.new(na, na, na, na, color=valColor, width = 2)

var line PPoC_l = line.new(na, na , na, na, color=pocColor, style = line.style_dashed, width = 2)
var line PVAH_l = line.new(na, na , na, na, color=vahColor, style = line.style_dashed, width = 2)
var line PVAL_l = line.new(na, na , na, na, color=valColor, style = line.style_dashed, width = 2)

if pointOfControl and pocExtend != 'None' 
    f_checkBreaches(a_poc_lines, pocExtend)

// ======
// MTF MA
// ======

// Inputs

// global input
i_hideFromLowerTf = input.bool(false, 'Hide MA from lower timeframe')
// label input
const string g_label = 'MA Labels'
i_showType = input.bool(false, 'Display MA Type', group = g_label)
i_showLen = input.bool(false, 'Display MA Length', group = g_label)
i_showTf = input.bool(false, 'Display MA Timeframe', group = g_label)
i_showN = input.bool(false, 'Display MA Number', group = g_label, tooltip = 'Helps you find and configure the moving average more easily')
i_labelOffset = input.int(0, 'Label offset', minval=0, group = g_label)
i_labelSize = input.string('normal', 'Label size', options = ['tiny', 'small', 'normal', 'large', 'huge'])

// Funcs
f_dema(_src, _length) =>
    e1 = ta.ema(_src, _length)
    e2 = ta.ema(e1, _length)
    2 * e1 - e2

f_tema(_src, _length) =>
    e1 = ta.ema(_src, _length)
    e2 = ta.ema(e1, _length)
    e3 = ta.ema(e2, _length)
    (3 * e1) - (3 * e2) + e3

f_smma(_src, _length) =>
    sma = ta.sma(_src, _length)
    float smma = 0.0
    smma := na(smma[1]) ? sma : (smma[1] * (_length - 1) + _src) / _length

f_ma(_type, _src, _len) =>
    switch _type
        "EMA: Exponential Moving Average" => ta.ema(_src, _len)
        "DEMA: Double Exponential Moving Average" => f_dema(_src, _len)
        "TEMA: Triple Exponential Moving Average" => f_tema(_src, _len)
        "VWMA: Volume Weighted Moving Average" => ta.vwma(_src, _len)
        "RMA: Rolling Moving Average" => ta.rma(_src, _len)
        "WMA: Weighted Moving Average" => ta.wma(_src, _len)
        "HMA: Hull Moving Average" => ta.hma(_src, _len)
        "SMA: Simple Moving Average" => ta.sma(_src, _len)
        "SWMA: Symmetrically Weighted Moving Average" => ta.swma(_src)
        "SMMA: Smoothed Moving Average" => f_smma(_src, _len)
        "VWAP: Volume Weighted Average Price (Daily)" => ta.vwap(_src)
        "MVWAP: Moving VWAP" => ta.vwap(_src, barstate.isfirst)
        "LSMA: Least Squares Moving Average" => ta.linreg(_src, _len, 0)

f_timeframeToHuman(_tf) =>
    seconds = timeframe.in_seconds(_tf)
    if seconds < 60
        _tf
    else if seconds < 3600
        str.tostring(seconds / 60) + 'm'
    else if seconds < 86400
        str.tostring(seconds / 60 / 60) + 'h'
    else
        switch _tf
            "1D" => "D"
            "1W" => "W"
            "1M" => "M"
            => str.tostring(_tf)

f_getSizeFromString(_size) =>
    switch _size
        "auto" => size.auto
        "tiny" => size.tiny
        "small" => size.small
        "normal" => size.normal
        "large" => size.large
        "huge" => size.huge

// FIX1
f_getLabelText(_tf, _type, _len, _n) =>
    t = ''
    maType1 = str.substring(_type, 0, str.pos(_type, ':'))

    if i_showType
        t := maType1

    if i_showLen and maType1 != "VWAP" and maType1 != "MVWAP" and maType1 != "SWMA"
        t += (t != '' ? ' ' : '') + str.tostring(_len)

    if i_showTf and _tf != ''
        t += (t != '' ? ' / ' : '') + f_timeframeToHuman(_tf)

    if i_showN
        t += (t != '' ? ' ' : '') + '#' + str.tostring(_n)
    t

labelSize = f_getSizeFromString(i_labelSize)

f_addMaLabel(_enabled, _n, _src, _price, _tf, _type, _len, _color, _offset) =>
    label l = na
    if _enabled and not na(_price)
        labelText = f_getLabelText(_tf, _type, _len, _n)
        if labelText != ''
            pos = chart.point.from_index(bar_index + i_labelOffset + _offset, _price)
            maTooltip = str.format("MA #{0}\nType: {1}\nLength: {2}\nTimeframe: {3}\nPrice: {4}", _n, str.replace(_type, ':', ' -'), _len, f_timeframeToHuman(_tf), _price)
            l := label.new(pos, text=labelText, color=color.new(color.black, 100), textcolor=_color, style=label.style_label_left, textalign=text.align_left, yloc=yloc.price, size = labelSize, tooltip = maTooltip)
    label.delete(l[1])

f_getMaConverted(_tf, _type, _src, _len) =>
    ma = f_ma(_type, _src, _len)
    [m, bindex] = request.security(syminfo.tickerid, _tf, [ma, bar_index])
    int lbindex = na
    lbindex := na(lbindex[1]) or bindex > lbindex[1] ? bindex : lbindex[1]
    lbindex != lbindex[1] or barstate.islast ? m : na

f_showInCurrentTimeframe(_hideInLowerTf, _tf) =>
    if _hideInLowerTf == false
        true
    else
        timeframe.in_seconds(_tf) >= timeframe.in_seconds()


// Plots

// line width
const int C_LINEWIDTH = 2

//------------------------------------
// MA #1
const string g_ma1 = 'Moving Average #1'
i_ma1_enabled = input.bool(true, 'Enabled', group = g_ma1)
i_ma1_tf = input.timeframe('240', 'Timeframe', group = g_ma1)
i_ma1_src = input.source(close, 'Source', group = g_ma1)
i_ma1_len = input.int(200, 'Length', group = g_ma1)
i_ma1_offset = input.int(0, 'Offset', group = g_ma1)
i_ma1_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma1)
i_ma1_color = input.color(color.rgb(255, 255, 255, 97), 'Color', group = g_ma1)

v_ma1 = f_getMaConverted(i_ma1_tf, i_ma1_type, i_ma1_src, i_ma1_len)
v_ma1_visible = i_ma1_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma1_tf)
plot(v_ma1_visible ? v_ma1 : na, color=i_ma1_color, linewidth=C_LINEWIDTH, title='MA #1', join=true, offset = i_ma1_offset)
f_addMaLabel(v_ma1_visible, 1, i_ma1_src, v_ma1, i_ma1_tf, i_ma1_type, i_ma1_len, i_ma1_color, i_ma1_offset)


//------------------------------------
// MA #2
const string g_ma2 = 'Moving Average #2'
i_ma2_enabled = input.bool(true, 'Enabled', group = g_ma2)
i_ma2_tf = input.timeframe('240', 'Timeframe', group = g_ma2)
i_ma2_src = input.source(close, 'Source', group = g_ma2)
i_ma2_len = input.int(300, 'Length', group = g_ma2)
i_ma2_offset = input.int(0, 'Offset', group = g_ma2)
i_ma2_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma2)
i_ma2_color = input.color(color.rgb(255, 255, 255, 97), 'Color', group = g_ma2)

v_ma2 = f_getMaConverted(i_ma2_tf, i_ma2_type, i_ma2_src, i_ma2_len)
v_ma2_visible = i_ma2_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma2_tf)
plot(v_ma2_visible ? v_ma2 : na, color=i_ma2_color, linewidth=C_LINEWIDTH, title='MA #2', join=true, offset = i_ma2_offset)
f_addMaLabel(v_ma2_visible, 2, i_ma2_src, v_ma2, i_ma2_tf, i_ma2_type, i_ma2_len, i_ma2_color, i_ma2_offset)


//------------------------------------
// MA #3
const string g_ma3 = 'Moving Average #3'
i_ma3_enabled = input.bool(true, 'Enabled', group = g_ma3)
i_ma3_tf = input.timeframe('240', 'Timeframe', group = g_ma3)
i_ma3_src = input.source(close, 'Source', group = g_ma3)
i_ma3_len = input.int(30, 'Length', group = g_ma3)
i_ma3_offset = input.int(0, 'Offset', group = g_ma3)
i_ma3_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma3)
i_ma3_color = input.color(color.rgb(76, 175, 79, 95), 'Color', group = g_ma3)

v_ma3 = f_getMaConverted(i_ma3_tf, i_ma3_type, i_ma3_src, i_ma3_len)
v_ma3_visible = i_ma3_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma3_tf)
plot(v_ma3_visible ? v_ma3 : na, color=i_ma3_color, linewidth=C_LINEWIDTH, title='MA #3', join=true, offset = i_ma3_offset)
f_addMaLabel(v_ma3_visible, 3, i_ma3_src, v_ma3, i_ma3_tf, i_ma3_type, i_ma3_len, i_ma3_color, i_ma3_offset)


//------------------------------------
// MA #4
const string g_ma4 = 'Moving Average #4'
i_ma4_enabled = input.bool(true, 'Enabled', group = g_ma4)
i_ma4_tf = input.timeframe('60', 'Timeframe', group = g_ma4)
i_ma4_src = input.source(close, 'Source', group = g_ma4)
i_ma4_len = input.int(200, 'Length', group = g_ma4)
i_ma4_offset = input.int(0, 'Offset', group = g_ma4)
i_ma4_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma4)
i_ma4_color = input.color(color.rgb(255, 82, 82, 95), 'Color', group = g_ma4)

v_ma4 = f_getMaConverted(i_ma4_tf, i_ma4_type, i_ma4_src, i_ma4_len)
v_ma4_visible = i_ma4_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma4_tf)
plot(v_ma4_visible ? v_ma4 : na, color=i_ma4_color, linewidth=C_LINEWIDTH, title='MA #4', join=true, offset = i_ma4_offset)
f_addMaLabel(v_ma4_visible, 4, i_ma4_src, v_ma4, i_ma4_tf, i_ma4_type, i_ma4_len, i_ma4_color, i_ma4_offset)


//------------------------------------
// MA #5
const string g_ma5 = 'Moving Average #5'
i_ma5_enabled = input.bool(false, 'Enabled', group = g_ma5)
i_ma5_tf = input.timeframe('', 'Timeframe', group = g_ma5)
i_ma5_src = input.source(close, 'Source', group = g_ma5)
i_ma5_len = input.int(50, 'Length', group = g_ma5)
i_ma5_offset = input.int(0, 'Offset', group = g_ma5)
i_ma5_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma5)
i_ma5_color = input.color(#22ab94, 'Color', group = g_ma5)

v_ma5 = f_getMaConverted(i_ma5_tf, i_ma5_type, i_ma5_src, i_ma5_len)
v_ma5_visible = i_ma5_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma5_tf)
plot(v_ma5_visible ? v_ma5 : na, color=i_ma5_color, linewidth=C_LINEWIDTH, title='MA #5', join=true, offset = i_ma5_offset)
f_addMaLabel(v_ma5_visible, 5, i_ma5_src, v_ma5, i_ma5_tf, i_ma5_type, i_ma5_len, i_ma5_color, i_ma5_offset)


//------------------------------------
// MA #6
const string g_ma6 = 'Moving Average #6'
i_ma6_enabled = input.bool(false, 'Enabled', group = g_ma6)
i_ma6_tf = input.timeframe('', 'Timeframe', group = g_ma6)
i_ma6_src = input.source(close, 'Source', group = g_ma6)
i_ma6_len = input.int(60, 'Length', group = g_ma6)
i_ma6_offset = input.int(0, 'Offset', group = g_ma6)
i_ma6_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma6)
i_ma6_color = input.color(#26c6da, 'Color', group = g_ma6)

v_ma6 = f_getMaConverted(i_ma6_tf, i_ma6_type, i_ma6_src, i_ma6_len)
v_ma6_visible = i_ma6_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma6_tf)
plot(v_ma6_visible ? v_ma6 : na, color=i_ma6_color, linewidth=C_LINEWIDTH, title='MA #6', join=true, offset = i_ma6_offset)
f_addMaLabel(v_ma6_visible, 6, i_ma6_src, v_ma6, i_ma6_tf, i_ma6_type, i_ma6_len, i_ma6_color, i_ma6_offset)


//------------------------------------
// MA #7
const string g_ma7 = 'Moving Average #7'
i_ma7_enabled = input.bool(false, 'Enabled', group = g_ma7)
i_ma7_tf = input.timeframe('', 'Timeframe', group = g_ma7)
i_ma7_src = input.source(close, 'Source', group = g_ma7)
i_ma7_len = input.int(70, 'Length', group = g_ma7)
i_ma7_offset = input.int(0, 'Offset', group = g_ma7)
i_ma7_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma7)
i_ma7_color = input.color(#3179f5, 'Color', group = g_ma7)

v_ma7 = f_getMaConverted(i_ma7_tf, i_ma7_type, i_ma7_src, i_ma7_len)
v_ma7_visible = i_ma7_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma7_tf)
plot(v_ma7_visible ? v_ma7 : na, color=i_ma7_color, linewidth=C_LINEWIDTH, title='MA #7', join=true, offset = i_ma7_offset)
f_addMaLabel(v_ma7_visible, 7, i_ma7_src, v_ma7, i_ma7_tf, i_ma7_type, i_ma7_len, i_ma7_color, i_ma7_offset)


//------------------------------------
// MA #8
const string g_ma8 = 'Moving Average #8'
i_ma8_enabled = input.bool(false, 'Enabled', group = g_ma8)
i_ma8_tf = input.timeframe('', 'Timeframe', group = g_ma8)
i_ma8_src = input.source(close, 'Source', group = g_ma8)
i_ma8_len = input.int(80, 'Length', group = g_ma8)
i_ma8_offset = input.int(0, 'Offset', group = g_ma8)
i_ma8_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma8)
i_ma8_color = input.color(#7e57c2, 'Color', group = g_ma8)

v_ma8 = f_getMaConverted(i_ma8_tf, i_ma8_type, i_ma8_src, i_ma8_len)
v_ma8_visible = i_ma8_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma8_tf)
plot(v_ma8_visible ? v_ma8 : na, color=i_ma8_color, linewidth=C_LINEWIDTH, title='MA #8', join=true, offset = i_ma8_offset)
f_addMaLabel(v_ma8_visible, 8, i_ma8_src, v_ma8, i_ma8_tf, i_ma8_type, i_ma8_len, i_ma8_color, i_ma8_offset)


//------------------------------------
// MA #9
const string g_ma9 = 'Moving Average #9'
i_ma9_enabled = input.bool(false, 'Enabled', group = g_ma9)
i_ma9_tf = input.timeframe('240', 'Timeframe', group = g_ma9)
i_ma9_src = input.source(close, 'Source', group = g_ma9)
i_ma9_len = input.int(9, 'Length', group = g_ma9)
i_ma9_offset = input.int(0, 'Offset', group = g_ma9)
i_ma9_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma9)
i_ma9_color = input.color(color.rgb(76, 175, 79, 90), 'Color', group = g_ma9)

v_ma9 = f_getMaConverted(i_ma9_tf, i_ma9_type, i_ma9_src, i_ma9_len)
v_ma9_visible = i_ma9_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma9_tf)
plot(v_ma9_visible ? v_ma9 : na, color=i_ma9_color, linewidth=C_LINEWIDTH, title='MA #9', join=true, offset = i_ma9_offset)
f_addMaLabel(v_ma9_visible, 9, i_ma9_src, v_ma9, i_ma9_tf, i_ma9_type, i_ma9_len, i_ma9_color, i_ma9_offset)


//------------------------------------
// MA #10
const string g_ma10 = 'Moving Average #10'
i_ma10_enabled = input.bool(false, 'Enabled', group = g_ma10)
i_ma10_tf = input.timeframe('240', 'Timeframe', group = g_ma10)
i_ma10_src = input.source(close, 'Source', group = g_ma10)
i_ma10_len = input.int(21, 'Length', group = g_ma10)
i_ma10_offset = input.int(0, 'Offset', group = g_ma10)
i_ma10_type = input.string('EMA: Exponential Moving Average', 'Type', options=["DEMA: Double Exponential Moving Average","EMA: Exponential Moving Average","HMA: Hull Moving Average","LSMA: Least Squares Moving Average","MVWAP: Moving VWAP","RMA: Rolling Moving Average","SMA: Simple Moving Average","SMMA: Smoothed Moving Average","SWMA: Symmetrically Weighted Moving Average","TEMA: Triple Exponential Moving Average","VWAP: Volume Weighted Average Price (Daily)","VWMA: Volume Weighted Moving Average","WMA: Weighted Moving Average"], group = g_ma10)
i_ma10_color = input.color(color.rgb(255, 82, 82, 90), 'Color', group = g_ma10)

v_ma10 = f_getMaConverted(i_ma10_tf, i_ma10_type, i_ma10_src, i_ma10_len)
v_ma10_visible = i_ma10_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma10_tf)
plot(v_ma10_visible ? v_ma10 : na, color=i_ma10_color, linewidth=C_LINEWIDTH, title='MA #10', join=true, offset = i_ma10_offset)
f_addMaLabel(v_ma10_visible, 10, i_ma10_src, v_ma10, i_ma10_tf, i_ma10_type, i_ma10_len, i_ma10_color, i_ma10_offset)

// ==============
// Heatmap Volume 
// ==============

// Inputs
lengthh = input.int(305, title='MA Length', minval = 2, tooltip = 'Moving Average Length\n\n- Smaller values will respond more quickly and activate more frequently. (Best for short-term analysis)\n- Larger values will have a slower response, will be less sensitive to small volume variations, and will highlight large volumes. (Best for long-term analysis)\n\nFormula: How many stdev is the volume far from the Moving Average?')
slength = input.int(305, title='Standard Deviation Length', minval=2, tooltip = 'Standard Deviation lookback period.\n\nFormula: How many stdev is the volume far from the Moving Average?')
g_hmz = 'Heatmap Threshold Multipliers'
thresholdExtraHigh = input.float(4, title='Extra High Multiplier', tooltip = 'Volume Threshold Multiplier\neg: 4 = 400% or 4 x Stdev above the mean', group=g_hmz)
thresholdHigh = input(2.5, title='High Multiplier', group=g_hmz)
thresholdMedium = input.float(1, title='Medium Multiplier', group=g_hmz)
thresholdNormal = input(-0.5, title='Normal Multiplier', group=g_hmz)

// Colors

// config
g_color = 'Color settings'
bcolor_enabled = input(true, 'Colored bars', group = g_color)
zmode = input.string('Backgrounds', 'Display Heatmap Zones as', options=['None', 'Lines', 'Backgrounds', 'Both'], group = g_color)
cmode = input.string('Heatmap', 'Color Mode', options=['Heatmap', 'Up/Down'], group = g_color, tooltip = '- Heatmap mode: colors based only on volume.\n- Up/Down mode: colors based on candle volume and direction.\nChange the cores below according to the selected mode.')

// heatmap colors
chm1 = #ff0000  // extra high red
chm2 = #ff7800  // high orange
chm3 = #ffcf03  // medium yellow
chm4 = #8f8f8f  // normal
chm5 = #5f5f5f  // low

// heatmap colors
g_mhcolor = 'Heatmap colors'
chmthresholdExtraHigh = input(chm1, 'Extra High', group=g_mhcolor)
chmthresholdHigh = input(chm2, 'High', group=g_mhcolor)
chmthresholdMedium = input(chm3, 'Medium', group=g_mhcolor)
chmthresholdNormal = input(chm4, 'Normal', group=g_mhcolor)
chmthresholdLow = input(chm5, 'Low', group=g_mhcolor)

// up colors
g_up = 'Up colors'
cupthresholdExtraHigh = input(#00FF00, 'Extra High', group = g_up)
cupthresholdHigh = input(#30FF30, 'High', group = g_up)
cupthresholdMedium = input(#60FF60, 'Medium', group = g_up)
cupthresholdNormal = input(#8FFF8F, 'Normal', group = g_up)
cupthresholdLow = input(#BFFFBF, 'Low', group = g_up)

// down colors
g_down = 'Down colors'
cdnthresholdExtraHigh = input(#FF0000, 'Extra High', group = g_down)
cdnthresholdHigh = input(#FF3030, 'High', group = g_down)
cdnthresholdMedium = input(#FF6060, 'Medium', group = g_down)
cdnthresholdNormal = input(#FF8F8F, 'Normal', group = g_down)
cdnthresholdLow = input(#FFBFBF, 'Low', group = g_down)

// threshold colors
cthresholdExtraHighUp = cmode == 'Heatmap' ? chmthresholdExtraHigh : cupthresholdExtraHigh
cthresholdHighUp = cmode == 'Heatmap' ? chmthresholdHigh : cupthresholdHigh
cthresholdMediumUp = cmode == 'Heatmap' ? chmthresholdMedium : cupthresholdMedium
cthresholdNormalUp = cmode == 'Heatmap' ? chmthresholdNormal : cupthresholdNormal
cthresholdLowUp = cmode == 'Heatmap' ? chmthresholdLow : cupthresholdLow

cthresholdExtraHighDn = cmode == 'Heatmap' ? chmthresholdExtraHigh : cdnthresholdExtraHigh
cthresholdHighDn = cmode == 'Heatmap' ? chmthresholdHigh : cdnthresholdHigh
cthresholdMediumDn = cmode == 'Heatmap' ? chmthresholdMedium : cdnthresholdMedium
cthresholdNormalDn = cmode == 'Heatmap' ? chmthresholdNormal : cdnthresholdNormal
cthresholdLowDn = cmode == 'Heatmap' ? chmthresholdLow : cdnthresholdLow

// Calcs

lengthh := lengthh > bar_index + 1 ? bar_index + 1 : lengthh
slength := slength > bar_index + 1 ? bar_index + 1 : slength

dir_hv = close > open
mean = ta.sma(volume, lengthh)
std = ta.stdev(volume, slength)

// how many stdev is the volume far from the mean?
// eg: stdbar = 2.5, is 2.5 * stdev above the mean (2.5 * stdev + mean)
stdbar = (volume - mean) / std 

bcolor = stdbar > thresholdExtraHigh ? dir_hv ? cthresholdExtraHighUp : cthresholdExtraHighDn : stdbar > thresholdHigh ? dir_hv ? cthresholdHighUp : cthresholdHighDn : stdbar > thresholdMedium ? dir_hv ? cthresholdMediumUp : cthresholdMediumDn : stdbar > thresholdNormal ? dir_hv ? cthresholdNormalUp : cthresholdNormalDn : dir_hv ? cthresholdLowUp : cthresholdLowDn
bodycolor = color.new(bcolor, 70)
plotcandle(open, high, low, close, title="Heatmap Candles", color=bodycolor, wickcolor=bcolor, bordercolor=bcolor, editable=false, force_overlay=true)


// =======================
// SpaceMan BTC Key Levels
// =======================

displayStyle = input.string(defval='Standard', title='Display Style', options=['Standard', 'Right Anchored'], inline='Display')
mergebool = input.bool(defval=true, title='Merge Levels?', inline='Display')
distanceright = input.int(defval=60, title='Distance', minval=5, maxval=500, inline='Dist')
radistance = input.int(defval=250, title='Anchor Distance', minval=5, maxval=500, inline='Dist')
labelsize = input.string(defval='Medium', title='Text Size', options=['Small', 'Medium', 'Large'])
linesize = input.string(defval='Small', title='Line Width', options=['Small', 'Medium', 'Large'], inline='Line')
linestyle = input.string(defval='Solid', title='Line Style', options=['Solid', 'Dashed', 'Dotted'], inline='Line')

GlobalTextType = input.bool(defval=true, title='Global Text ShortHand', tooltip='Enable for shorthand text on all text')
var globalcoloring = input.bool(defval=true, title='Global Coloring', tooltip='Enable for all color controls via one color', inline='GC')
GlobalColor = input.color(title='', defval=color.rgb(255, 255, 255, 95), inline='GC')

[daily_time, daily_open] = request.security(syminfo.tickerid, 'D', [time, open], lookahead=barmerge.lookahead_on)
[dailyh_time, dailyh_open] = request.security(syminfo.tickerid, 'D', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[dailyl_time, dailyl_open] = request.security(syminfo.tickerid, 'D', [time[1], low[1]], lookahead=barmerge.lookahead_on)

cdailyh_open = request.security(syminfo.tickerid, 'D', high, lookahead=barmerge.lookahead_on)
cdailyl_open = request.security(syminfo.tickerid, 'D', low, lookahead=barmerge.lookahead_on)
var monday_time = time
var monday_high = high
var monday_low = low

[weekly_time, weekly_open] = request.security(syminfo.tickerid, 'W', [time, open], lookahead=barmerge.lookahead_on)
[weeklyh_time, weeklyh_open] = request.security(syminfo.tickerid, 'W', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[weeklyl_time, weeklyl_open] = request.security(syminfo.tickerid, 'W', [time[1], low[1]], lookahead=barmerge.lookahead_on)
[monthly_time, monthly_open] = request.security(syminfo.tickerid, 'M', [time, open], lookahead=barmerge.lookahead_on)
[monthlyh_time, monthlyh_open] = request.security(syminfo.tickerid, 'M', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[monthlyl_time, monthlyl_open] = request.security(syminfo.tickerid, 'M', [time[1], low[1]], lookahead=barmerge.lookahead_on)
[quarterly_time, quarterly_open] = request.security(syminfo.tickerid, '3M', [time, open], lookahead=barmerge.lookahead_on)
[quarterlyh_time, quarterlyh_open] = request.security(syminfo.tickerid, '3M', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[quarterlyl_time, quarterlyl_open] = request.security(syminfo.tickerid, '3M', [time[1], low[1]], lookahead=barmerge.lookahead_on)
[yearly_time, yearly_open] = request.security(syminfo.tickerid, '12M', [time, open], lookahead=barmerge.lookahead_on)
[yearlyh_time, yearlyh_open] = request.security(syminfo.tickerid, '12M', [time, high], lookahead=barmerge.lookahead_on)
[yearlyl_time, yearlyl_open] = request.security(syminfo.tickerid, '12M', [time, low], lookahead=barmerge.lookahead_on)
[intra_time, intra_open] = request.security(syminfo.tickerid, '240', [time, open], lookahead=barmerge.lookahead_on)
[intrah_time, intrah_open] = request.security(syminfo.tickerid, '240', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[intral_time, intral_open] = request.security(syminfo.tickerid, '240', [time[1], low[1]], lookahead=barmerge.lookahead_on)

//------------------------------ Inputs -------------------------------

var is_intra_enabled = input.bool(defval=false, title='Open', group='4H', inline='4H')
var is_intrarange_enabled = input.bool(defval=false, title='Prev H/L', group='4H', inline='4H')
var is_intram_enabled = input.bool(defval=false, title='Prev Mid', group='4H', inline='4H')
IntraTextType = input.bool(defval=false, title='ShortHand', group='4H', inline='4Hsh')

var is_daily_enabled = input.bool(defval=true, title='Open', group='Daily', inline='Daily')
var is_dailyrange_enabled = input.bool(defval=false, title='Prev H/L', group='Daily', inline='Daily')
var is_dailym_enabled = input.bool(defval=false, title='Prev Mid', group='Daily', inline='Daily')
DailyTextType = input.bool(defval=false, title='ShortHand', group='Daily', inline='Dailysh')

var is_monday_enabled = input.bool(defval=true, title='Range', group='Monday Range', inline='Monday')
var is_monday_mid = input.bool(defval=true, title='Mid', group='Monday Range', inline='Monday')
var untested_monday = false
MondayTextType = input.bool(defval=false, title='ShortHand', group='Monday Range', inline='Mondaysh')

var is_weekly_enabled = input.bool(defval=true, title='Open', group='Weekly', inline='Weekly')
var is_weeklyrange_enabled = input.bool(defval=true, title='Prev H/L', group='Weekly', inline='Weekly')
var is_weekly_mid = input.bool(defval=true, title='Prev Mid', group='Weekly', inline='Weekly')
WeeklyTextType = input.bool(defval=false, title='ShortHand', group='Weekly', inline='Weeklysh')

var is_monthly_enabled = input.bool(defval=true, title='Open', group='Monthly', inline='Monthly')
var is_monthlyrange_enabled = input.bool(defval=true, title='Prev H/L', group='Monthly', inline='Monthly')
var is_monthly_mid = input.bool(defval=true, title='Prev Mid', group='Monthly', inline='Monthly')
MonthlyTextType = input.bool(defval=false, title='ShortHand', group='Monthly', inline='Monthlysh')

var is_quarterly_enabled = input.bool(defval=true, title='Open', group='Quarterly', inline='Quarterly')
var is_quarterlyrange_enabled = input.bool(defval=false, title='Prev H/L', group='Quarterly', inline='Quarterly')
var is_quarterly_mid = input.bool(defval=true, title='Prev Mid', group='Quarterly', inline='Quarterly')
QuarterlyTextType = input.bool(defval=false, title='ShortHand', group='Quarterly', inline='Quarterlysh')

var is_yearly_enabled = input.bool(defval=true, title='Open', group='Yearly', inline='Yearly')
var is_yearlyrange_enabled = input.bool(defval=false, title='Current H/L', group='Yearly', inline='Yearly')
var is_yearly_mid = input.bool(defval=true, title='Mid', group='Yearly', inline='Yearly')
YearlyTextType = input.bool(defval=false, title='ShortHand', group='Yearly', inline='Yearlysh')

// var is_londonrange_enabled = input.bool(defval=false, title='London Range', group='FX Sessions', inline='FX')
// var is_usrange_enabled = input.bool(defval=false, title='New York Range', group='FX Sessions', inline='FX')
// var is_asiarange_enabled = input.bool(defval=false, title='Asia Range', group='FX Sessions', inline='FX')
// SessionTextType = input.bool(defval=false, title='ShortHand', group='FX Sessions', inline='FXColor')

// Londont = input.session("0800-1600", "London Session")
// USt = input.session("1400-2100", "New York Session")
// Asiat = input.session("0000-0900", "Tokyo Session")

DailyColor = input.color(title='', defval=#08bcd4, group='Daily', inline='Dailysh')
MondayColor = input.color(title='', defval=color.white, group='Monday Range', inline='Mondaysh')
WeeklyColor = input.color(title='', defval=#fffcbc, group='Weekly', inline='Weeklysh')
MonthlyColor = input.color(title='', defval=#08d48c, group='Monthly', inline='Monthlysh')
YearlyColor = input.color(title='', defval=color.red, group='Yearly', inline='Yearlysh')
quarterlyColor = input.color(title='', defval=color.red, group='Quarterly', inline='Quarterlysh')
IntraColor = input.color(title='', defval=color.orange, group='4H', inline='4Hsh')
// LondonColor = input.color(title='', defval=color.white, group='FX Sessions', inline='FXColor')
// USColor = input.color(title='', defval=color.white, group='FX Sessions', inline='FXColor')
// AsiaColor = input.color(title='', defval=color.white, group='FX Sessions', inline='FXColor')
var pdhtext = GlobalTextType or DailyTextType ? 'PDH' : 'Prev Day High'
var pdltext = GlobalTextType or DailyTextType ? 'PDL' : 'Prev Day Low'
var dotext = GlobalTextType or DailyTextType ? 'DO' : 'Daily Open'
var pdmtext = GlobalTextType or DailyTextType ? 'PDM' : 'Prev Day Mid'

var pwhtext = GlobalTextType or WeeklyTextType ? 'PWH' : 'Prev Week High'
var pwltext = GlobalTextType or WeeklyTextType ? 'PWL' : 'Prev Week Low'
var wotext = GlobalTextType or WeeklyTextType ? 'WO' : 'Weekly Open'
var pwmtext = GlobalTextType or WeeklyTextType ? 'PWM' : 'Prev Week Mid'

var pmhtext = GlobalTextType or MonthlyTextType ? 'PMH' : 'Prev Month High'
var pmltext = GlobalTextType or MonthlyTextType ? 'PML' : 'Prev Month Low'
var motext = GlobalTextType or MonthlyTextType ? 'MO' : 'Monthly Open'
var pmmtext = GlobalTextType or MonthlyTextType ? 'PMM' : 'Prev Month Mid'

var pqhtext = GlobalTextType or QuarterlyTextType ? 'PQH' : 'Prev Quarter High'
var pqltext = GlobalTextType or QuarterlyTextType ? 'PQL' : 'Prev Quarter Low'
var qotext = GlobalTextType or QuarterlyTextType ? 'QO' : 'Quarterly Open'
var pqmtext = GlobalTextType or QuarterlyTextType ? 'PQM' : 'Prev Quarter Mid'

var cyhtext = GlobalTextType or YearlyTextType ? 'CYH' : 'Current Year High'
var cyltext = GlobalTextType or YearlyTextType ? 'CYL' : 'Current Year Low'
var yotext = GlobalTextType or YearlyTextType ? 'YO' : 'Yearly Open'
var cymtext = GlobalTextType or YearlyTextType ? 'CYM' : 'Current Year Mid'

var pihtext = GlobalTextType or IntraTextType ? 'P-4H-H' : 'Prev 4H High'
var piltext = GlobalTextType or IntraTextType ? 'P-4H-L' : 'Prev 4H Low'
var iotext = GlobalTextType or IntraTextType ? '4H-O' : '4H Open'
var pimtext = GlobalTextType or IntraTextType ? 'P-4H-M' : 'Prev 4H Mid'

var pmonhtext = GlobalTextType or MondayTextType ? 'MDAY-H' : 'Monday High'
var pmonltext = GlobalTextType or MondayTextType ? 'MDAY-L' : 'Monday Low'
var pmonmtext = GlobalTextType or MondayTextType ? 'MDAY-M' : 'Monday Mid'

// var lhtext = GlobalTextType or SessionTextType ? 'Lon-H' : 'London High'
// var lltext = GlobalTextType or SessionTextType ? 'Lon-L' : 'London Low'
// var lotext = GlobalTextType or SessionTextType ? 'Lon-O' : 'London Open'


// var ushtext = GlobalTextType or SessionTextType ? 'NY-H' : 'New York High'
// var usltext = GlobalTextType or SessionTextType ? 'NY-L' : 'New York Low'
// var usotext = GlobalTextType or SessionTextType ? 'NY-O' : 'New York Open'

// var asiahtext = GlobalTextType or SessionTextType ? 'AS-H' : 'Asia High'
// var asialtext = GlobalTextType or SessionTextType ? 'AS-L' : 'Asia Low'
// var asiaotext = GlobalTextType or SessionTextType ? 'AS-O' : 'Asia Open'

if globalcoloring == true
    DailyColor := GlobalColor
    MondayColor := GlobalColor
    WeeklyColor := GlobalColor
    MonthlyColor := GlobalColor
    YearlyColor := GlobalColor
    quarterlyColor := GlobalColor
    IntraColor := GlobalColor
    IntraColor


if weekly_time != weekly_time[1]
    untested_monday := false
    untested_monday

if is_monday_enabled == true and untested_monday == false
    untested_monday := true
    monday_time := daily_time
    monday_high := cdailyh_open
    monday_low := cdailyl_open
    monday_low


linewidthint = 1
if linesize == 'Small'
    linewidthint := 1
    linewidthint
if linesize == 'Medium'
    linewidthint := 2
    linewidthint
if linesize == 'Large'
    linewidthint := 3
    linewidthint

var DEFAULT_LINE_WIDTH = linewidthint
var DEFAULT_TAIL_WIDTH = linewidthint

fontsize = size.small

if labelsize == 'Small'
    fontsize := size.small
    fontsize

if labelsize == 'Medium'
    fontsize := size.normal
    fontsize

if labelsize == 'Large'
    fontsize := size.large
    fontsize

linestyles = line.style_solid
if linestyle == 'Dashed'
    linestyles := line.style_dashed
    linestyles

if linestyle == 'Dotted'
    linestyles := line.style_dotted
    linestyles

var DEFAULT_LABEL_SIZE = fontsize
var DEFAULT_LABEL_STYLE = label.style_none
var DEFAULT_EXTEND_RIGHT = distanceright


//------------------------------ Plotting ------------------------------
var pricearray = array.new_float(0)
var labelarray = array.new_label(0)
f_LevelMerge(pricearray, labelarray, currentprice, currentlabel, currentcolor) =>
    if array.includes(pricearray, currentprice)
        whichindex = array.indexof(pricearray, currentprice)
        labelhold = array.get(labelarray, whichindex)
        whichtext = label.get_text(labelhold)

        label.set_text(labelhold, label.get_text(currentlabel) + ' / ' + whichtext)
        label.set_text(currentlabel, '')
        label.set_textcolor(labelhold, currentcolor)
    else
        array.push(pricearray, currentprice)
        array.push(labelarray, currentlabel)


var can_show_daily = is_daily_enabled and timeframe.isintraday
var can_show_weekly = is_weekly_enabled and not timeframe.isweekly and not timeframe.ismonthly
var can_show_monthly = is_monthly_enabled and not timeframe.ismonthly

get_limit_right(bars) =>
    timenow + (time - time[1]) * bars

// the following code doesn't need to be processed on every candle
if barstate.islast
    is_weekly_open = dayofweek == dayofweek.monday
    is_monthly_open = dayofmonth == 1
    can_draw_daily = (is_weekly_enabled ? not is_weekly_open : true) and (is_monthly_enabled ? not is_monthly_open : true)
    can_draw_weekly = is_monthly_enabled ? not(is_monthly_open and is_weekly_open) : true
    can_draw_intra = is_intra_enabled
    can_draw_intrah = is_intrarange_enabled
    can_draw_intral = is_intrarange_enabled
    can_draw_intram = is_intram_enabled
    pricearray := array.new_float(0)
    labelarray := array.new_label(0)
            

    if can_draw_intra
        intra_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intra_time := get_limit_right(radistance)
            intra_time


        var intra_line = line.new(x1=intra_time, x2=intra_limit_right, y1=intra_open, y2=intra_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var intra_label = label.new(x=intra_limit_right, y=intra_open, text=iotext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intra_line, intra_time)
        line.set_x2(intra_line, intra_limit_right)
        line.set_y1(intra_line, intra_open)
        line.set_y2(intra_line, intra_open)
        label.set_x(intra_label, intra_limit_right)
        label.set_y(intra_label, intra_open)
        label.set_text(intra_label, iotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intra_open, intra_label, IntraColor)

    if can_draw_intrah
        intrah_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intrah_time := get_limit_right(radistance)
            intrah_time

        var intrah_line = line.new(x1=intrah_time, x2=intrah_limit_right, y1=intrah_open, y2=intrah_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var intrah_label = label.new(x=intrah_limit_right, y=intrah_open, text=pihtext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intrah_line, intrah_time)
        line.set_x2(intrah_line, intrah_limit_right)
        line.set_y1(intrah_line, intrah_open)
        line.set_y2(intrah_line, intrah_open)
        label.set_x(intrah_label, intrah_limit_right)
        label.set_y(intrah_label, intrah_open)
        label.set_text(intrah_label, pihtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intrah_open, intrah_label, IntraColor)

    if can_draw_intral
        intral_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intral_time := get_limit_right(radistance)
            intral_time

        var intral_line = line.new(x1=intral_time, x2=intral_limit_right, y1=intral_open, y2=intral_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var intral_label = label.new(x=intral_limit_right, y=intral_open, text=piltext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intral_line, intral_time)
        line.set_x2(intral_line, intral_limit_right)
        line.set_y1(intral_line, intral_open)
        line.set_y2(intral_line, intral_open)
        label.set_x(intral_label, intral_limit_right)
        label.set_y(intral_label, intral_open)
        label.set_text(intral_label, piltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intral_open, intral_label, IntraColor)

    if can_draw_intram
        intram_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        intram_time = intrah_time
        intram_open = (intral_open + intrah_open) / 2
        if displayStyle == 'Right Anchored'
            intram_time := get_limit_right(radistance)
            intram_time

        var intram_line = line.new(x1=intram_time, x2=intram_limit_right, y1=intram_open, y2=intram_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var intram_label = label.new(x=intram_limit_right, y=intram_open, text=pimtext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(intram_line, intram_time)
        line.set_x2(intram_line, intram_limit_right)
        line.set_y1(intram_line, intram_open)
        line.set_y2(intram_line, intram_open)
        label.set_x(intram_label, intram_limit_right)
        label.set_y(intram_label, intram_open)
        label.set_text(intram_label, pimtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intram_open, intram_label, IntraColor)

    if is_monday_enabled
        monday_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)
            monday_time

        var monday_line = line.new(x1=monday_time, x2=monday_limit_right, y1=monday_high, y2=monday_high, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monday_label = label.new(x=monday_limit_right, y=monday_high, text=pmonhtext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monday_line, monday_time)
        line.set_x2(monday_line, monday_limit_right)
        line.set_y1(monday_line, monday_high)
        line.set_y2(monday_line, monday_high)
        label.set_x(monday_label, monday_limit_right)
        label.set_y(monday_label, monday_high)
        label.set_text(monday_label, pmonhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monday_high, monday_label, MondayColor)

    if is_monday_enabled
        monday_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)
            monday_time

        var monday_low_line = line.new(x1=monday_time, x2=monday_limit_right, y1=monday_low, y2=monday_low, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monday_low_label = label.new(x=monday_limit_right, y=monday_low, text=pmonltext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monday_low_line, monday_time)
        line.set_x2(monday_low_line, monday_limit_right)
        line.set_y1(monday_low_line, monday_low)
        line.set_y2(monday_low_line, monday_low)
        label.set_x(monday_low_label, monday_limit_right)
        label.set_y(monday_low_label, monday_low)
        label.set_text(monday_low_label, pmonltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monday_low, monday_low_label, MondayColor)

    if is_monday_mid
        mondaym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)

        mondaym_open = (monday_high + monday_low) / 2
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)
            monday_time

        var mondaym_line = line.new(x1=monday_time, x2=mondaym_limit_right, y1=mondaym_open, y2=mondaym_open, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var mondaym_label = label.new(x=mondaym_limit_right, y=mondaym_open, text=pmonmtext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(mondaym_line, monday_time)
        line.set_x2(mondaym_line, mondaym_limit_right)
        line.set_y1(mondaym_line, mondaym_open)
        line.set_y2(mondaym_line, mondaym_open)
        label.set_x(mondaym_label, mondaym_limit_right)
        label.set_y(mondaym_label, mondaym_open)
        label.set_text(mondaym_label, pmonmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, mondaym_open, mondaym_label, MondayColor)

    if is_daily_enabled
        daily_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            daily_time := get_limit_right(radistance)
            daily_time

        var daily_line = line.new(x1=daily_time, x2=daily_limit_right, y1=daily_open, y2=daily_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var daily_label = label.new(x=daily_limit_right, y=daily_open, text=dotext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(daily_line, daily_time)
        line.set_x2(daily_line, daily_limit_right)
        line.set_y1(daily_line, daily_open)
        line.set_y2(daily_line, daily_open)
        label.set_x(daily_label, daily_limit_right)
        label.set_y(daily_label, daily_open)
        label.set_text(daily_label, dotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, daily_open, daily_label, DailyColor)

    if is_dailyrange_enabled
        dailyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            dailyh_time := get_limit_right(radistance)
            dailyh_time

        var dailyh_line = line.new(x1=dailyh_time, x2=dailyh_limit_right, y1=dailyh_open, y2=dailyh_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var dailyh_label = label.new(x=dailyh_limit_right, y=dailyh_open, text=pdhtext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(dailyh_line, dailyh_time)
        line.set_x2(dailyh_line, dailyh_limit_right)
        line.set_y1(dailyh_line, dailyh_open)
        line.set_y2(dailyh_line, dailyh_open)
        label.set_x(dailyh_label, dailyh_limit_right)
        label.set_y(dailyh_label, dailyh_open)
        label.set_text(dailyh_label, pdhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailyh_open, dailyh_label, DailyColor)

    if is_dailyrange_enabled
        dailyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            dailyl_time := get_limit_right(radistance)
            dailyl_time

        var dailyl_line = line.new(x1=dailyl_time, x2=dailyl_limit_right, y1=dailyl_open, y2=dailyl_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var dailyl_label = label.new(x=dailyl_limit_right, y=dailyl_open, text=pdltext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(dailyl_line, dailyl_time)
        line.set_x2(dailyl_line, dailyl_limit_right)
        line.set_y1(dailyl_line, dailyl_open)
        line.set_y2(dailyl_line, dailyl_open)
        label.set_x(dailyl_label, dailyl_limit_right)
        label.set_y(dailyl_label, dailyl_open)
        label.set_text(dailyl_label, pdltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailyl_open, dailyl_label, DailyColor)

    if is_dailym_enabled
        dailym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        dailym_time = dailyh_time
        dailym_open = (dailyl_open + dailyh_open) / 2
        if displayStyle == 'Right Anchored'
            dailym_time := get_limit_right(radistance)
            dailym_time
        var dailym_line = line.new(x1=dailym_time, x2=dailym_limit_right, y1=dailym_open, y2=dailym_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var dailym_label = label.new(x=dailym_limit_right, y=dailym_open, text=pdmtext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(dailym_line, dailym_time)
        line.set_x2(dailym_line, dailym_limit_right)
        line.set_y1(dailym_line, dailym_open)
        line.set_y2(dailym_line, dailym_open)
        label.set_x(dailym_label, dailym_limit_right)
        label.set_y(dailym_label, dailym_open)
        label.set_text(dailym_label, pdmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailym_open, dailym_label, DailyColor)

    if is_weekly_enabled
        weekly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        cweekly_time = weekly_time
        if displayStyle == 'Right Anchored'
            cweekly_time := get_limit_right(radistance)
            cweekly_time

        var weekly_line = line.new(x1=cweekly_time, x2=weekly_limit_right, y1=weekly_open, y2=weekly_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var weekly_label = label.new(x=weekly_limit_right, y=weekly_open, text=wotext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weekly_line, cweekly_time)
        line.set_x2(weekly_line, weekly_limit_right)
        line.set_y1(weekly_line, weekly_open)
        line.set_y2(weekly_line, weekly_open)
        label.set_x(weekly_label, weekly_limit_right)
        label.set_y(weekly_label, weekly_open)
        label.set_text(weekly_label, wotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weekly_open, weekly_label, WeeklyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label
    // if is_weekly_open and can_show_daily
            // label.set_text(weekly_label, "DO / WO            ")

    if is_weeklyrange_enabled
        weeklyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            weeklyh_time := get_limit_right(radistance)
            weeklyh_time

        var weeklyh_line = line.new(x1=weeklyh_time, x2=weeklyh_limit_right, y1=weeklyh_open, y2=weeklyh_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var weeklyh_label = label.new(x=weeklyh_limit_right, y=weeklyh_open, text=pwhtext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weeklyh_line, weeklyh_time)
        line.set_x2(weeklyh_line, weeklyh_limit_right)
        line.set_y1(weeklyh_line, weeklyh_open)
        line.set_y2(weeklyh_line, weeklyh_open)
        label.set_x(weeklyh_label, weeklyh_limit_right)
        label.set_y(weeklyh_label, weeklyh_open)
        label.set_text(weeklyh_label, pwhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklyh_open, weeklyh_label, WeeklyColor)


    if is_weeklyrange_enabled
        weeklyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            weeklyl_time := get_limit_right(radistance)
            weeklyl_time

        var weeklyl_line = line.new(x1=weeklyl_time, x2=weeklyl_limit_right, y1=weekly_open, y2=weekly_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var weeklyl_label = label.new(x=weeklyl_limit_right, y=weeklyl_open, text=pwltext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weeklyl_line, weeklyl_time)
        line.set_x2(weeklyl_line, weeklyl_limit_right)
        line.set_y1(weeklyl_line, weeklyl_open)
        line.set_y2(weeklyl_line, weeklyl_open)
        label.set_x(weeklyl_label, weeklyl_limit_right)
        label.set_y(weeklyl_label, weeklyl_open)
        label.set_text(weeklyl_label, pwltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklyl_open, weeklyl_label, WeeklyColor)

    if is_weekly_mid
        weeklym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        weeklym_time = weeklyh_time
        weeklym_open = (weeklyl_open + weeklyh_open) / 2
        if displayStyle == 'Right Anchored'
            weeklym_time := get_limit_right(radistance)
            weeklym_time

        var weeklym_line = line.new(x1=weeklym_time, x2=weeklym_limit_right, y1=weeklym_open, y2=weeklym_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var weeklym_label = label.new(x=weeklym_limit_right, y=weeklym_open, text=pwmtext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(weeklym_line, weeklym_time)
        line.set_x2(weeklym_line, weeklym_limit_right)
        line.set_y1(weeklym_line, weeklym_open)
        line.set_y2(weeklym_line, weeklym_open)
        label.set_x(weeklym_label, weeklym_limit_right)
        label.set_y(weeklym_label, weeklym_open)
        label.set_text(weeklym_label, pwmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklym_open, weeklym_label, WeeklyColor)

    if is_yearlyrange_enabled
        yearlyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            yearlyl_time := get_limit_right(radistance)
            yearlyl_time

        var yearlyl_line = line.new(x1=yearlyl_time, x2=yearlyl_limit_right, y1=yearlyl_open, y2=yearlyl_open, color=YearlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var yearlyl_label = label.new(x=yearlyl_limit_right, y=yearlyl_open, text=cyltext, style=DEFAULT_LABEL_STYLE, textcolor=YearlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(yearlyl_line, yearlyl_time)
        line.set_x2(yearlyl_line, yearlyl_limit_right)
        line.set_y1(yearlyl_line, yearlyl_open)
        line.set_y2(yearlyl_line, yearlyl_open)
        label.set_x(yearlyl_label, yearlyl_limit_right)
        label.set_y(yearlyl_label, yearlyl_open)
        label.set_text(yearlyl_label, cyltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, yearlyl_open, yearlyl_label, YearlyColor)

    if is_yearlyrange_enabled
        yearlyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            yearlyh_time := get_limit_right(radistance)
            yearlyh_time

        var yearlyh_line = line.new(x1=yearlyh_time, x2=yearlyh_limit_right, y1=yearlyh_open, y2=yearlyh_open, color=YearlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var yearlyh_label = label.new(x=yearlyh_limit_right, y=yearlyh_open, text=cyhtext, style=DEFAULT_LABEL_STYLE, textcolor=YearlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(yearlyh_line, yearlyh_time)
        line.set_x2(yearlyh_line, yearlyh_limit_right)
        line.set_y1(yearlyh_line, yearlyh_open)
        line.set_y2(yearlyh_line, yearlyh_open)
        label.set_x(yearlyh_label, yearlyh_limit_right)
        label.set_y(yearlyh_label, yearlyh_open)
        label.set_text(yearlyh_label, cyhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, yearlyh_open, yearlyh_label, YearlyColor)

    if is_yearly_enabled
        yearly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            yearly_time := get_limit_right(radistance)
            yearly_time

        var yearly_line = line.new(x1=yearly_time, x2=yearly_limit_right, y1=yearly_open, y2=yearly_open, color=YearlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var yearly_label = label.new(x=yearly_limit_right, y=yearly_open, text=yotext, style=DEFAULT_LABEL_STYLE, textcolor=YearlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(yearly_line, yearly_time)
        line.set_x2(yearly_line, yearly_limit_right)
        line.set_y1(yearly_line, yearly_open)
        line.set_y2(yearly_line, yearly_open)
        label.set_x(yearly_label, yearly_limit_right)
        label.set_y(yearly_label, yearly_open)
        label.set_text(yearly_label, yotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, yearly_open, yearly_label, YearlyColor)

    if is_yearly_mid
        yearlym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        yearlym_time = yearlyh_time
        yearlym_open = (yearlyl_open + yearlyh_open) / 2
        if displayStyle == 'Right Anchored'
            yearlym_time := get_limit_right(radistance)
            yearlym_time

        var yearlym_line = line.new(x1=yearlym_time, x2=yearlym_limit_right, y1=yearlym_open, y2=yearlym_open, color=YearlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var yearlym_label = label.new(x=yearlym_limit_right, y=yearlym_open, text=cymtext, style=DEFAULT_LABEL_STYLE, textcolor=YearlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(yearlym_line, yearlym_time)
        line.set_x2(yearlym_line, yearlym_limit_right)
        line.set_y1(yearlym_line, yearlym_open)
        line.set_y2(yearlym_line, yearlym_open)
        label.set_x(yearlym_label, yearlym_limit_right)
        label.set_y(yearlym_label, yearlym_open)
        label.set_text(yearlym_label, cymtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, yearlym_open, yearlym_label, YearlyColor)

    if is_quarterly_enabled
        quarterly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            quarterly_time := get_limit_right(radistance)
            quarterly_time

        var quarterly_line = line.new(x1=quarterly_time, x2=quarterly_limit_right, y1=quarterly_open, y2=quarterly_open, color=quarterlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var quarterly_label = label.new(x=quarterly_limit_right, y=quarterly_open, text=qotext, style=DEFAULT_LABEL_STYLE, textcolor=quarterlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(quarterly_line, quarterly_time)
        line.set_x2(quarterly_line, quarterly_limit_right)
        line.set_y1(quarterly_line, quarterly_open)
        line.set_y2(quarterly_line, quarterly_open)
        label.set_x(quarterly_label, quarterly_limit_right)
        label.set_y(quarterly_label, quarterly_open)
        label.set_text(quarterly_label, qotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, quarterly_open, quarterly_label, quarterlyColor)

    if is_quarterlyrange_enabled
        quarterlyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            quarterlyh_time := get_limit_right(radistance)
            quarterlyh_time

        var quarterlyh_line = line.new(x1=quarterlyh_time, x2=quarterlyh_limit_right, y1=quarterlyh_open, y2=quarterlyh_open, color=quarterlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var quarterlyh_label = label.new(x=quarterlyh_limit_right, y=quarterlyh_open, text=pqhtext, style=DEFAULT_LABEL_STYLE, textcolor=quarterlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(quarterlyh_line, quarterlyh_time)
        line.set_x2(quarterlyh_line, quarterlyh_limit_right)
        line.set_y1(quarterlyh_line, quarterlyh_open)
        line.set_y2(quarterlyh_line, quarterlyh_open)
        label.set_x(quarterlyh_label, quarterlyh_limit_right)
        label.set_y(quarterlyh_label, quarterlyh_open)
        label.set_text(quarterlyh_label, pqhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, quarterlyh_open, quarterlyh_label, quarterlyColor)

    if is_quarterlyrange_enabled
        quarterlyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            quarterlyl_time := get_limit_right(radistance)
            quarterlyl_time

        var quarterlyl_line = line.new(x1=quarterlyl_time, x2=quarterlyl_limit_right, y1=quarterlyl_open, y2=quarterlyl_open, color=quarterlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var quarterlyl_label = label.new(x=quarterlyl_limit_right, y=quarterlyl_open, text=pqltext, style=DEFAULT_LABEL_STYLE, textcolor=quarterlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(quarterlyl_line, quarterlyl_time)
        line.set_x2(quarterlyl_line, quarterlyl_limit_right)
        line.set_y1(quarterlyl_line, quarterlyl_open)
        line.set_y2(quarterlyl_line, quarterlyl_open)
        label.set_x(quarterlyl_label, quarterlyl_limit_right)
        label.set_y(quarterlyl_label, quarterlyl_open)

        label.set_text(quarterlyl_label, pqltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, quarterlyl_open, quarterlyl_label, quarterlyColor)

    if is_quarterly_mid
        quarterlym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        quarterlym_time = quarterlyh_time
        quarterlym_open = (quarterlyl_open + quarterlyh_open) / 2
        if displayStyle == 'Right Anchored'
            quarterlym_time := get_limit_right(radistance)
            quarterlym_time
        var quarterlym_line = line.new(x1=quarterlym_time, x2=quarterlym_limit_right, y1=quarterlym_open, y2=quarterlym_open, color=quarterlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var quarterlym_label = label.new(x=quarterlym_limit_right, y=quarterlym_open, text=pqmtext, style=DEFAULT_LABEL_STYLE, textcolor=quarterlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(quarterlym_line, quarterlym_time)
        line.set_x2(quarterlym_line, quarterlym_limit_right)
        line.set_y1(quarterlym_line, quarterlym_open)
        line.set_y2(quarterlym_line, quarterlym_open)
        label.set_x(quarterlym_label, quarterlym_limit_right)
        label.set_y(quarterlym_label, quarterlym_open)

        label.set_text(quarterlym_label, pqmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, quarterlym_open, quarterlym_label, quarterlyColor)

    if is_monthlyrange_enabled
        monthlyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthlyl_time := get_limit_right(radistance)
            monthlyl_time

        var monthlyl_line = line.new(x1=monthlyl_time, x2=monthlyl_limit_right, y1=monthlyl_open, y2=monthlyl_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monthlyl_label = label.new(x=monthlyl_limit_right, y=monthlyl_open, text=pmltext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyl_line, monthlyl_time)
        line.set_x2(monthlyl_line, monthlyl_limit_right)
        line.set_y1(monthlyl_line, monthlyl_open)
        line.set_y2(monthlyl_line, monthlyl_open)
        label.set_x(monthlyl_label, monthlyl_limit_right)
        label.set_y(monthlyl_label, monthlyl_open)
        label.set_text(monthlyl_label, pmltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlyl_open, monthlyl_label, MonthlyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label

    if is_monthlyrange_enabled
        monthlyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthlyh_time := get_limit_right(radistance)
            monthlyh_time

        var monthlyh_line = line.new(x1=monthlyh_time, x2=monthlyh_limit_right, y1=monthlyh_open, y2=monthlyh_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monthlyh_label = label.new(x=monthlyh_limit_right, y=monthlyh_open, text=pmhtext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyh_line, monthlyl_time)
        line.set_x2(monthlyh_line, monthlyh_limit_right)
        line.set_y1(monthlyh_line, monthlyh_open)
        line.set_y2(monthlyh_line, monthlyh_open)
        label.set_x(monthlyh_label, monthlyh_limit_right)
        label.set_y(monthlyh_label, monthlyh_open)
        label.set_text(monthlyh_label, pmhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlyh_open, monthlyh_label, MonthlyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label

    if is_monthly_mid
        monthlym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        monthlym_time = monthlyh_time
        monthlym_open = (monthlyl_open + monthlyh_open) / 2
        if displayStyle == 'Right Anchored'
            monthlym_time := get_limit_right(radistance)
            monthlym_time
        var monthlym_line = line.new(x1=monthlym_time, x2=monthlym_limit_right, y1=monthlym_open, y2=monthlym_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monthlym_label = label.new(x=monthlym_limit_right, y=monthlym_open, text=pmmtext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(monthlym_line, monthlym_time)
        line.set_x2(monthlym_line, monthlym_limit_right)
        line.set_y1(monthlym_line, monthlym_open)
        line.set_y2(monthlym_line, monthlym_open)
        label.set_x(monthlym_label, monthlym_limit_right)
        label.set_y(monthlym_label, monthlym_open)
        label.set_text(monthlym_label, pmmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlym_open, monthlym_label, MonthlyColor)

    if is_monthly_enabled
        monthly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthly_time := get_limit_right(radistance)
            monthly_time

        var monthlyLine = line.new(x1=monthly_time, x2=monthly_limit_right, y1=monthly_open, y2=monthly_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var monthlyLabel = label.new(x=monthly_limit_right, y=monthly_open, text=motext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyLine, monthly_time)
        line.set_x2(monthlyLine, monthly_limit_right)
        line.set_y1(monthlyLine, monthly_open)
        line.set_y2(monthlyLine, monthly_open)
        label.set_x(monthlyLabel, monthly_limit_right)
        label.set_y(monthlyLabel, monthly_open)
        label.set_text(monthlyLabel, motext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthly_open, monthlyLabel, MonthlyColor)


        // the monthly open can be the weekly open (monday 1st) and/or daily open too
        // only the monthly will be draw, in these case we update its label
        // if is_monthly_open
        //     if can_show_daily
        //         label.set_text(monthlyLabel, "DO / MO            ")
        //     if is_weekly_open
        //         if can_show_weekly
        //             label.set_text(monthlyLabel, "WO / MO            ")
        //         if can_show_daily and can_show_weekly
        //             label.set_text(monthlyLabel, "DO / WO / MO                ")

        // the start of the line is drew from the first week of the month
        // if the first day of the weekly candle (monday) is the 2nd of the month
        // we fix the start of the line position on the Prev weekly candle
        if timeframe.isweekly and dayofweek(monthly_time) != dayofweek.monday
            line.set_x1(monthlyLine, monthly_time - (weekly_time - weekly_time[1]))

// ==============
// 4H Supertrend
// ==============       

Periods = input.int(title="ATR Period", defval=10)
Multiplier = input.float(title="ATR Multiplier", step=0.1, defval=3.0)
changeATR= input.bool(title="Change ATR Calculation Method ?", defval=true)
showsignals = input.bool(title="Show Buy/Sell Signals ?", defval=false)
highlighting = input.bool(title="Highlighter On/Off ?", defval=false)

// Requesting 4-hour data
res = "240"
st_src = request.security(syminfo.tickerid, res, hl2)
atr2 = request.security(syminfo.tickerid, res, ta.sma(ta.tr, Periods))
atr = changeATR ? request.security(syminfo.tickerid, res, ta.atr(Periods)) : atr2
up = st_src - (Multiplier * atr)
up1 = nz(up[1], up)
up := request.security(syminfo.tickerid, res, close[1]) > up1 ? math.max(up, up1) : up
dn = st_src + (Multiplier * atr)
dn1 = nz(dn[1], dn)
dn := request.security(syminfo.tickerid, res, close[1]) < dn1 ? math.min(dn, dn1) : dn
var trend = 1
trend := nz(trend[1], trend)
trend := trend == -1 and request.security(syminfo.tickerid, res, close) > dn1 ? 1 : trend == 1 and request.security(syminfo.tickerid, res, close) < up1 ? -1 : trend

upPlot = plot(trend == 1 ? up : na, title="Up Trend", style=plot.style_linebr, linewidth=2, color=color.new(color.green, 95))
dnPlot = plot(trend == 1 ? na : dn, title="Down Trend", style=plot.style_linebr, linewidth=2, color=color.new(color.red, 95))